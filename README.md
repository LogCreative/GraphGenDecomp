# 图生成与分解器
2020年秋季 问题求解与实践大作业

*李子龙 518070910095 F1903301*

> Copyright (C) 2020 by LogCreative, All Rights Reserved.

## 问题重述

开发一个图自动生成器
1. 随机生成一个有向图，将图放置到指定文件中，每一行如下格式
    - <节点编号>：节点
	- <出发节点编号、结束节点编号、权重>：有向边
2. 开发一个图分解器
    - 分割图文件
     	- 将上述图分为若干子图，每个子图中节点数不大于 n。
     	- A图分割后，每个子图可以用单独的文件保存：如 A1,A2,A3,...
     	- 令子图之间的交互（即能够跨越子图边界的边）权重之和最小
     	- 我们将挑选若干自动生成的图，对比大家生成的权重之和值。在结果正确的前提下，计算权重之和越小，分数越高。
         	- 优化子图存储
     	- 上述图分割算法导致分割成的多个子图之间存在重复的节点，请设计一个方法，使
          	- 多个子图文件中分别载入程序后，不存在重复的节点
     	- 每个子图可以最多增加一个虚节点（如子图的文件名），代表外界（即其他子图）对该子图的引用
     	- 设计一个算法，将多个子图合并及删除虚节点后，检查与原图A一致。输出分割边的权重和。
    - 子图上算法
     	- 指定一个点，列出计算所有经有向边可达的节点
     	- 指定两个点，输出最短路径
     	- 如果指定的节点不存在，报错即可

## 公共类 `GraphCommon`

在开始的无 UI 编译时期，存储为同一个公共类 `GraphCommon`，后面因为需要使用全局的非静态变量，将头文件分离。该类的完整版本还是请看 `GraphDecomp.h` 中的相关定义。

### 结构体

该类定义了三个小结构体：
- 节点类 `node`
- 有向边类 `edge`
- 节点结构 `nodeStruct`（用于计算邻接矩阵）。

前两个都重载了输入输出运算符，以符合目标格式。

||输入|输出|
|----|-----|-----|
|`node`|`<P1>`|`<1>`|
|`edge`|`<P1 P2 2.0>`|`<1,2,2.0>`|

前缀符号以及分割符可以在后面调整。值得一提的是，优化后子图的虚边定义为如下的格式：
```
<起始点,虚点符号,<文件名.终止节点,权重>>
<1,-1,<O1.2,2.0>>
```
在本程序中，`-1`被定义虚节点符号。

节点结构中定义了三个成员：
- `node Node;` 中心节点
- `map<int, double> adjMatCol;` 邻接矩阵列数值
- `double totalWeight = 0;` 节点发出边总权重

并通过两个私有函数同步更新这些数值。

### 公共成员

该类定义了两个公共成员：
- `set<int> isoNodes` 包含了所有的孤立节点(isolated nodes)，也就是完全不连通的部分。
- `map<int, vector<edge>> adjListGraph`，邻接表图，仅包含连通部分节点，对于有些连通节点可能为发出空边的集合，即
```
adjListGraph[node] = vector<edge>({});
```

### 公共函数

该类定义了四个公共函数。
- `readNode` 通过输入文本流读取明确定义的节点信息
- `readEdge` 通过文本流读取有向边的信息。
- `readFile` 通过文本流读取文件信息。
- `readRawFile` 通过文本流读取特定格式的文件信息。

### 私有函数
该类定义了三个私有函数。
- `insertNode` 插入节点，包含了对虚节点的检查机制。
- `pushBackEdge` 向邻接表插入边，也包含了对节点是否为虚节点的转换检查机制。
- `isolateNodes` 将`readNode`后的集合去除根据`readEdge`所读取的连接边点，变为孤立节点的集合。

## 图生成器 `GraphGen`

图生成器的类 `GraphGen` 是 `GraphCommonGen` 的派生类。

本程序的图生成器有几个参数需要设置：
- **节点类型** `nodeType`：`continuous`连续编号的, `discrete`离散的。
- 边生成类型 `edgeType`：`Tree`树（不含环路）, `Graph`图（带有环路）。
- **连通图类型** `isoType`：`Single` 单个连通图, `Multi` 多个连通图。
- **节点编号增长量** `MAX_INCREASEMENT`：在离散编号模式下，每次生成一个节点都会增长一个数字，这个数字不会超过最大增长量 。
- **最大孩子数** `MAX_CHILD`：每个节点的发出有向边个数不会超过最大孩子数 。
- **最大连通子图数** `MAX_ISOGRAPH`：在多个连通图生成模式下，每个图的连通子图数不会超过最大连通子图数。
- **节点行数占比** `Node / Lines`：在新文件模式下，仍然会生成随机个数的节点数，但是只输出占比量的节点行数，其余为有向边的行。

该程序将会根据上述参数，递增而随机地生成节点编号。然后通过层序遍历生成各个边，如果没有环路的限制，则有可能随机到一个环路节点上去。

随机数采用下面的代码生成：
```cpp
srand((unsigned)time(0)*(++gseed));
return 1.0 * rand() / RAND_MAX;	
```
当然，这种方式依然不是特别特别随机，但已经足够。

## 图分解器 `GraphDecomp`

图分解器类 `GraphDecomp` 是 `GraphCommon` 的派生类，提供接口。

处理器类 `Processor` 同样是 `GraphCommon` 的派生类，提供文件处理相关的函数。

值处理器类 `ValueProcessor` 是 `Processor` 的派生类，提供邻接矩阵计算相关的函数。

### 分解器 `Decomposer`

分解器类 `Decomposer` 是 `ValueProcessor` 的派生类，采用 Kerning-Lin 算法（[*An efficient heuristic procedure for partitioning graphs*](https://ieeexplore.ieee.org/document/6771089/),1969），将其改进为有向边算法。

对于两节点有向边的损失，可以作为无向边处理，在本程序中定义损失为：
$$c_{ab} = c_{\overline{ab}}+c_{\overline{ba}}$$

对于两个集合A,B，各个集合中的对应边a,b，将**外损失**定义为：
$$E_a=\sum_{y \in B}c_{ay}$$

**内损失**定义为：
$$I_a=\sum_{x \in A}c_{ax}$$

**内外差**定义为：
$$D_z = E_z - I_z, \forall z \in S$$

**损失缩减量**定义为：
$$g_{ab} = D_a + D_b - 2c_{ab}$$

可以设置算法的猛烈程度 `DecompSol`，来影响分解时间和分解效果，对于大规模运算集会有显著的影响：
- `rough` 按照顺序分割，最快(`order`)。
- `lessfil` 减少过滤次数，快一些(`faster`)。
- `onepass` 每次只进行一次优化，居中(`medium`)。
- `ll` 取用局部最优（D 优先算法），慢一些(`harder`)。
- `kl` 标准算法，强力优化（g 优先算法），最慢(`hardest`)。

Kerninghan-Lin 算法的主要过程：对于两个集合A,B计算D值，循环以下过程：

1. 对于集合 A,B 计算 D 值。
2. 将集合记为 Ap,Bp
3. 选择Ap中的ai和Bp中的bi，使得g(ai,bi)是最大值。
4. 交换两个集合中的ai和bi。
5. 重复2~4过程n次。
6. 选择k使得G=g1+···+gk是最大的。
7. 如果G大于0，移动a1,...ak与b1,...,bk，从3开始继续循环。
8. 如果G小于0，则意味着负优化，不再移动，结束。

在Kerninghan-Lin的原算法中，是需要在4中直接去除两个元素，但是实验证明这么做的效果没有这种好，因为计算G的意义就是为了看交换到哪一步就是最好的优化，而在我们需要保持原集合大小不变的情况下，不应当在算法中间尝试减少集合的大小。

- `kl` 模式就是采用上述算法。
- `ll` 模式对步骤3进行了改进，仅仅通过选择两个集合中最大的D对应的元素进行交换。
- `onepass` 对步骤7进行放宽，只进行一次优化，就退出。
- `lessfil` 继续对步骤5进行优化，只重复3次。
- `rough` 模式就是对集合进行顺序二分，直至集合大小符合要求。

### 评估器 `Evaluater`

独立的评估器类为 `Evaluater`，当然 `Decomposer` 内会在完成分割后进行评估。但主要的评估函数 `Evaluate()` 都来自于父类 `ValueProcessor`。

首先需要计算每一对元素的邻接权重矩阵，需要进行
$n^2$次计算。

如果将n个元素几乎平均地分配到元素个数为|P|个集合中，共有n/|P|个集合，则需要进行对每两个集合间的每两个元素计算，需要$C_{\frac{n}{|P|}}^2C_{|P|}^2=O(n^2)$次计算，算出损失值。

### 优化器 `Optimizer`

叶子节点存在彼处，因为限制的是存储的节点数，而不是边数！

### 检查器 `Checker`



### 可达节点

由于优化器将该节点的发出边全部覆盖了，所以虚边发出作为等待寻找的队列。

### 最短路径

采用 SPFA 算法。

## 图预览(选做)


500

hardest 40s

2000

hardest 16min+ (没完)
lessfil 
onepass 60min+
order 3.5min		CHK 2.5min