# 图生成与分解器
2020年秋季 问题求解与实践大作业

![](https://cdn.jsdelivr.net/gh/LogCreative/report/header.png)

> Copyright (C) 2020 by LogCreative, All Rights Reserved. To learn more about the author, please visit https://github.com/LogCreative .
>
> (LC) No. 0211

![](https://cdn.jsdelivr.net/gh/LogCreative/report/program.gif)

> **使用：** 可以在 [发布栏](https://github.com/LogCreative/GraphGenDecomp/releases) 看到该软件的 Windows 发布版。（其余版本的编译正在尝试，欢迎PR）该软件可以随机生成子图，并根据比较有时间效率的启发式算法分割图形以限制每个子图的大小，有时间预期并可视化图。
> 
> **编译：** 需要在 VS 的 include 文件夹加入 FL 的头文件以及 lib 文件夹加入已经编译好的 FLTK 库文件。或者仅查看命令行未使用 FLTK 库的部分。
> 
> **原理：** 更为详尽的说明，请见 [项目报告](https://github.com/LogCreative/GraphGenDecomp/blob/master/report/GraphGenDecomp.pdf)。

## 问题重述

开发一个图自动生成器
1. 随机生成一个有向图，将图放置到指定文件中，每一行如下格式
    - <节点编号>：节点
	- <出发节点编号、结束节点编号、权重>：有向边
2. 开发一个图分解器
    - 分割图文件
     	- 将上述图分为若干子图，每个子图中节点数不大于 n。
     	- A图分割后，每个子图可以用单独的文件保存：如 A1,A2,A3,...
     	- 令子图之间的交互（即能够跨越子图边界的边）权重之和最小
     	- 我们将挑选若干自动生成的图，对比大家生成的权重之和值。在结果正确的前提下，计算权重之和越小，分数越高。
         	- 优化子图存储
     	- 上述图分割算法导致分割成的多个子图之间存在重复的节点，请设计一个方法，使
          	- 多个子图文件中分别载入程序后，不存在重复的节点
     	- 每个子图可以最多增加一个虚节点（如子图的文件名），代表外界（即其他子图）对该子图的引用
     	- 设计一个算法，将多个子图合并及删除虚节点后，检查与原图A一致。输出分割边的权重和。
    - 子图上算法
     	- 指定一个点，列出计算所有经有向边可达的节点
     	- 指定两个点，输出最短路径
     	- 如果指定的节点不存在，报错即可

## 公共类 `GraphCommon`

在开始的无 UI 编译时期，存储为同一个公共类 `GraphCommon`，后面因为需要使用全局的非静态变量，将头文件分离。该类的完整版本还是请看 `GraphDecomp.h` 中的相关定义。

### 结构体

该类定义了三个小结构体：
- 节点类 `node`
- 有向边类 `edge`
- 节点结构 `nodeStruct`（用于计算邻接矩阵）。

前两个都重载了输入输出运算符，以符合目标格式。

||输入|输出|
|----|-----|-----|
|`node`|`<P1>`|`<1>`|
|`edge`|`<P1 P2 2.0>`|`<1,2,2.0>`|

前缀符号以及分割符可以在后面调整。值得一提的是，优化后子图的虚边定义为如下的格式：
```
<起始点,虚点符号,<文件名.终止节点,权重>>
<1,-1,<O1.2,2.0>>
```
在本程序中，`-1`被定义虚节点符号。

节点结构中定义了三个成员：
- `node Node;` 中心节点
- `map<int, double> adjMatCol;` 邻接矩阵列数值
- `double totalWeight = 0;` 节点发出边总权重

并通过两个私有函数同步更新这些数值。

### 公共成员

该类定义了两个公共成员：
- `set<int> isoNodes` 包含了所有的孤立节点(isolated nodes)，也就是完全不连通的部分。
- `map<int, vector<edge>> adjListGraph`，邻接表图，仅包含连通部分节点，对于有些连通节点可能为发出空边的集合，即
```
adjListGraph[node] = vector<edge>({});
```

### 公共函数

该类定义了四个公共函数。
- `readNode` 通过输入文本流读取明确定义的节点信息
- `readEdge` 通过文本流读取有向边的信息。
- `readFile` 通过文本流读取文件信息。
- `readRawFile` 通过文本流读取特定格式的文件信息。

### 私有函数
该类定义了三个私有函数。
- `insertNode` 插入节点，包含了对虚节点的检查机制。
- `pushBackEdge` 向邻接表插入边，也包含了对节点是否为虚节点的转换检查机制。
- `isolateNodes` 将`readNode`后的集合去除根据`readEdge`所读取的连接边点，变为孤立节点的集合。

## 图生成器 `GraphGen`

图生成器的类 `GraphGen` 是 `GraphCommonGen` 的派生类。

本程序的图生成器有几个参数需要设置：
- **节点类型** `nodeType`：`continuous`连续编号的, `discrete`离散的。
- 边生成类型 `edgeType`：`Tree`树（不含环路）, `Graph`图（带有环路）。
- **连通图类型** `isoType`：`Single` 单个连通图, `Multi` 多个连通图。
- **节点编号增长量** `MAX_INCREASEMENT`：在离散编号模式下，每次生成一个节点都会增长一个数字，这个数字不会超过最大增长量 。
- **最大孩子数** `MAX_CHILD`：每个节点的发出有向边个数不会超过最大孩子数 。
- **最大连通子图数** `MAX_ISOGRAPH`：在多个连通图生成模式下，每个图的连通子图数不会超过最大连通子图数。
- **节点行数占比** `Node / Lines`：在新文件模式下，仍然会生成随机个数的节点数，但是只输出占比量的节点行数，其余为有向边的行。

该程序将会根据上述参数，递增而随机地生成节点编号。然后通过层序遍历生成各个边，如果没有环路的限制，则有可能随机到一个环路节点上去。

随机数采用下面的代码生成：
```cpp
srand((unsigned)time(0)*(++gseed));
return 1.0 * rand() / RAND_MAX;	
```
当然，这种方式依然不是特别特别随机，但已经足够。

## 图分解器 `GraphDecomp`

图分解器类 `GraphDecomp` 是 `GraphCommon` 的派生类，为前端提供提供统一接口。

处理器类 `Processor` 同样是 `GraphCommon` 的派生类，提供文件处理相关的函数。

值处理器类 `ValueProcessor` 是 `Processor` 的派生类，提供邻接矩阵计算相关的函数。

### 分解器 `Decomposer`

分解器类 `Decomposer` 是 `ValueProcessor` 的派生类，采用 Kerning-Lin 算法（[*An efficient heuristic procedure for partitioning graphs*](https://ieeexplore.ieee.org/document/6771089/),1969），将其改进为有向边算法。

对于两节点有向边的损失，可以作为无向边处理，在本程序中定义损失为：
$$c_{ab} = c_{\overline{ab}}+c_{\overline{ba}}$$

对于两个集合A,B，各个集合中的对应边a,b，将**外损失**定义为：
$$E_a=\sum_{y \in B}c_{ay}$$

**内损失**定义为：
$$I_a=\sum_{x \in A}c_{ax}$$

**内外差**定义为：
$$D_z = E_z - I_z, \forall z \in S$$

**损失缩减量**定义为：
$$g_{ab} = D_a + D_b - 2c_{ab}$$

可以设置算法的猛烈程度 `DecompSol`，来影响分解时间和分解效果，对于大规模运算集会有显著的影响：
- `rough` 按照顺序分割，最快(`order`)。
- `bfs` 采用广度优先搜索算法，快一些(`bfs`)。
- `onepass` 每次只进行一次优化，居中(`medium`)。
- `ll` 取用局部最优（D 优先算法），慢一些(`harder`)。
- `kl` 标准算法，强力优化（g 优先算法），最慢(`hardest`)。

Kerninghan-Lin 算法的主要过程：对于两个集合A,B计算D值，循环以下过程：

1. 对于集合 A,B 计算 D 值。
2. 将集合记为 Ap,Bp
3. 选择Ap中的ai和Bp中的bi，使得g(ai,bi)是最大值。
4. 交换两个集合中的ai和bi。
5. 重复2~4过程n次。
6. 选择k使得G=g1+···+gk是最大的。
7. 如果G大于0，移动a1,...ak与b1,...,bk，从3开始继续循环。
8. 如果G小于0，则意味着负优化，不再移动，结束。

在Kerninghan-Lin的原算法中，是需要在4中直接去除两个元素，但是实验证明这么做的效果没有这种好，因为计算G的意义就是为了看交换到哪一步就是最好的优化，而在我们需要保持原集合大小不变的情况下，不应当在算法中间尝试减少集合的大小。

- `kl` 模式就是采用上述算法。
- `ll` 模式对步骤3进行了改进，仅仅通过选择两个集合中最大的D对应的元素进行交换。
- `onepass` 对步骤7进行放宽，只进行一次优化，就退出。对于步骤5只重复原次数的四分之一。
- `bfs` 直接采用广度优先搜索，每次选择最大连接权重的节点遍历其子节点，直至每个集合达到集合个数上限。
- `rough` 模式就是对集合进行顺序二分，直至集合大小符合要求。

节点分配完毕后，将会将节点及其**所有**发出边存储在对应文件中。

### 评估器 `Evaluater`

对于外部分解文件的评估，该评估器定义节点的存储位置优先级如下：
1. 对于以节点形式存储的节点，存在对应的文件中
2. 对于第一次以有向边起点存储的节点，存在对应的文件中
3. 连通节点中的叶子节点将会存储在最后一次出现的文件中

独立的评估器类为 `Evaluater`，当然 `Decomposer` 内会在完成分割后进行评估。但主要的评估函数 `Evaluate()` 都来自于父类 `ValueProcessor`。

首先需要计算每一对元素的邻接权重矩阵，需要进行
$n^2$次计算。

如果将n个元素几乎平均地分配到元素个数为|P|个集合中，共有n/|P|个集合，则需要进行对每两个集合间的每两个元素计算，需要$C_{\frac{n}{|P|}}^2|P|^2=O(n^2)$次计算，算出损失值。

最后计算总权重，计算损失矩阵上对角线部分（包含对角线）的和。

该运算的成本较高，设置了 `CALC afer DECOMP` 选项以选择跳过计算权重部分。

### 优化器 `Optimizer`

优化器 `Optimizer` 是 `Processor` 的子类。

由本程序产生的分解子图，都会将节点存储位置以节点形式存储在对应文件中。优化器仅仅优化末尾节点，使其指向虚节点，并存储对应的文件位置。

分解器保证了所有的节点及其发出边都在同一个文件中，所以起始节点不会为虚节点。而如果起始节点为虚节点，将会对后面的寻找可达节点和最短路径造成极大的障碍，因为就难以预料起始节点在哪些文件中，最终很有可能沦为变相合并子图的过程，将会不符合题意。所以该程序限制只有终止节点为虚节点。

### 检查器 `Checker`

检查器 `Checker` 是 `Processor` 的子类，用以检查主图与分解图、分解图与优化图之间是否存储一致。

重载了集合比较函数，定义了映射比较函数，用于比较两者的鼓励节点存储与邻接表图存储是否都是一致的。

### 访达器 `Finder`

访达器 `Finder` 是 `Processor` 的子类，用于寻找可达节点与最短路径。

#### 可达节点 `ReachablePoints`

本程序所生成的优化后子图文件，节点存储位置将会存储所有发出边，虚节点只适用于有向边结束节点。因此，在这种限制规则下，可以将文件视作**广义节点**，当访问该点时出现虚边指出该文件，则输入文件访问队列，在该文件访问完毕后，访问队列中的下一个文件以及相应的节点。这样就可以在子图访问的前提下，获取所有的可达节点。

当然使用该算法会导致读取不同格式的子图文件做寻找算法时出现找不全的情形（比如起始节点为虚节点的情形）。

#### 最短路径 `ShortestPath`

采用 SPFA 算法。仍然在只有终止节点为虚节点的限制下，仿照上述可达节点的做法依次访问从起始节点开始的所有可达节点，每访问一个节点，都会考虑从上一个节点通过该有向边能否比原来的权重更少，如果是，则更新该节点的权重值，并存储路径到prev中，并放入访问队列中。

SPFA 在形式上和BFS非常类似，不同的是BFS中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进，于是再次用来改进其它的点，这样反复迭代下去。这种算法相比于 dijkstra 更适合于多子图上最短路径的寻找，没有使用排除访问的方法。

### 性能评估


对算法进行时间复杂度的分析。设总节点数为N，需要将子集的最大节点数目降到n以下，
- `order`,`bfs` 遍历节点，运算次数为 N。
- `harder` 采用 D 计算优先算法，在第 i 层的比较中，共需要优化 2^{i-1} 对，对于 `harder` 算法而言，没优化一对需要子优化 N/2^i 次，每次需要遍历2个 D 表，每个表有 N/2^i 个元素。故 `harder` 的时间复杂度为：N^2-Nn
- `medium` 恰好时上述的 1/4。当然，如果计算 G 时循环没有通过进度会进行回溯。
- `hardest` 采用 g 计算优先算法，这一次不是遍历 D 表，而是对每个节点对都计算 g。 故 `hardest` 的时间复杂度为：N^3/6-Nn^2/6

以上分析将会作为进度显示的依据，该程序通过更新一个弹出窗口的标题来显示进度与剩余时间。值得一提的是，为了让刷新没有那么频繁，只有到整数进度时才会进行刷新。

在评测时，20s 左右都是可以接受的，所以：
- 对于 $0\leq n\leq 1000$ 的图，都可以使用 `hardest` 模式，以期获得更好的分解效果。
- 对于 $1000 < n\leq 3000$ 的图，都可以使用 `harder` 模式，时间上不仅可以缩减为 `hardest` 的 $\frac{2}{3}$，效果上甚至可能会比 `hardest` 的要略好，因为都是局部最优算法，并不一定是全局最优。
- 对于 $3000 < n \leq 7000$ 的图，都可以使用 `medium` 模式，进一步缩减时间，并保证比 `harder` 更高的性价比。
- 对于 $n > 7000$ 的图，使用 `bfs` 模式节约时间，Kerninghan-Lin 算法所需要的时间过长，尽管效果提升可能比较明显。但是 `bfs` 模式 可以保证平稳的 50 \% 割边比例，也即保证基线的 $\frac{1}{3}$ 优化率。
- 如果分割限制比例向下调整，则算法就需要降档，以满足时间限制。当然，从时间复杂度的分析来看，分割成过细的子图会导致评估割边权重部分耗费过多的时间，可以考虑关闭 `CLAC after DECOMP` 选项以期大幅减少时间耗费量与内存占用率。

## 图预览

为了可视化图的分割情况，拓展性地创建了图预览器，便于分析结果。

首先设置了一些小的结构：
- `priorityQueue_m` 是手写的优先队列（最小化堆），便于从一个数组直接建堆，节约时间。
- `nodeConn` 是一个小型的节点连接结构。用于后面的节点分布和涂色计算。
- `SinglePrevReader` 单图读取器是 `Processor` 的派生类，用于读取单个图的节点情况与连接边情况。
- `MultiPrevReader` 多图读取器是 `Processor` 的派生类，用于读取多个图的节点情况与连接边情况，其中一些参量是通过每个文件初始化 `SinglePrevReader` 直接获得的。

`GraphView` 是 FLTK 库中 `Fl_Widget` 的子类，用于展示图形。

外部通过调用 `RefreshView` 函数刷新视图，传入文件路径和过滤器（可选），在初始化参量后，计算所有节点中最大的连接权重节点和最大边权重，用于后面的涂色。调用 `redraw` 绘制图形。

`redraw` 即调用 `draw()` 函数。
- 首先会通过 `refreshFborder()` 更新每个文件的画布边界，布局格子的边长为最近的大的平方根。
- 接着绘制有向边。由于方向在切割问题的切割上没有特别的作用，所以在此处没有标定方向。有向边的颜色透明度等于权重/全局最大权重，如果是内部边，为白色；如果是虚边，为黄色。
- 接着绘制节点。主界面有三个选项可以选择：`None` 表示不绘制节点，`Node` 表示仅绘制圆点，`Node + Label` 表示既绘制圆点也标记节点编号。节点的不透明度等于节点的发出边权重和/全局最大值。
- 而节点位置的确定由结构体 `SnakeArray` 获得 (OJ-1021)，由外至里，节点所连接的其他节点数递增，中心区域最多，格子的边长也是最近的大的平方根 + 1。

绘制可达节点和最短路径。
- 可达节点的绘制是通过向图预览器注册 `set<node> nodeR` 实现，通过修改分解器的相关接口，使其返回一个节点集合，每个节点包含所在文件的位置编号。
- 最短路径的绘制是通过向图预览器注册 `queue<node> shortestPathO` 实现，最短路径就是一个节点队列，将节点之间通过是否为虚边相互连接。
- 以上两种情况绘制时都会将其余的部分变暗为原来的 50%，仅突出可达节点或者是最短路径。